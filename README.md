> [!CAUTION]
> This ML-KEM implementation is conformant with ML-KEM draft standard https://doi.org/10.6028/NIST.FIPS.203.ipd and I also *try* to make it timing leakage free, using **dudect** (see https://github.com/oreparaz/dudect) -based tests, but be informed that this implementation is not yet audited. *If you consider using it in production, please be careful !*

# ML-KEM (formerly known as Kyber)
Module-Lattice -based Key Encapsulation Mechanism Standard by NIST.

## Motivation

ML-KEM is being standardized by NIST as post-quantum secure key encapsulation mechanism (KEM), which can be used for key establishment, between two parties, communicating over insecure channel.

ML-KEM offers an *IND-CCA-secure* Key Encapsulation Mechanism - its security is based on the hardness of solving the learning-with-errors (LWE) problem in module (i.e. structured) lattices.

ML-KEM is built on top of *IND-CPA-secure K-PKE*, where two communicating parties, both generating their key pairs, while publishing only their public keys to each other, can encrypt fixed length ( = 32 -bytes ) message using peer's public key. Cipher text can be decrypted by corresponding secret key ( which is private to the keypair owner ) and 32 -bytes message can be recovered back. Then a slightly tweaked Fujisakiâ€“Okamoto (FO) transform is applied on *IND-CPA-secure K-PKE* - giving us the *IND-CCA-secure ML-KEM* construction. In KEM scheme, two parties interested in establishing a secure communication channel, over public & insecure channel, can generate a 32 -bytes shared secret key. Now they can be use this 32 -bytes shared secret key in any symmetric key primitive, either for encrypting their communication (in much faster way) or deriving new/ longer keys.

Algorithm | Input | Output
--- | :-: | --:
KeyGen | - | Public Key and Secret Key
Encapsulation | Public Key | Cipher Text and 32B Shared Secret
Decapsulation | Secret Key and Cipher Text | 32B Shared Secret

Here I'm maintaining `kyber` - a C++20 header-only `constexpr` library, implementing ML-KEM, supporting ML-KEM-{512, 768, 1024} parameter sets, as defined in table 2 of ML-KEM draft standard. It's pretty easy to use, see [usage](#usage).

> [!NOTE]
> Find ML-KEM draft standard @ https://doi.org/10.6028/NIST.FIPS.203.ipd - this is the document that I followed when implementing ML-KEM. I suggest you go through the specification to get an in-depth understanding of the scheme.

## Prerequisites

- A C++ compiler with C++20 standard library such as `clang++`/ `g++`.

```bash
$ clang++ --version
Ubuntu clang version 17.0.6 (9ubuntu1)
Target: x86_64-pc-linux-gnu
Thread model: posix
InstalledDir: /usr/bin
```

- Build tools such as `make`, `cmake`.

```bash
$ make --version
GNU Make 4.3

$ cmake --version
cmake version 3.25.1
```

- For testing ML-KEM implementation, you need to globally install `google-test` library and headers. Follow guide @ https://github.com/google/googletest/tree/main/googletest#standalone-cmake-project, if you don't have it installed.
- For benchmarking ML-KEM implementation, you'll need to have `google-benchmark` header and library globally installed. I found guide @ https://github.com/google/benchmark#installation helpful.

> [!NOTE]
> If you are on a machine running GNU/Linux kernel and you want to obtain *CPU cycle* count for ML-KEM routines, you should consider building `google-benchmark` library with `libPFM` support, following https://gist.github.com/itzmeanjan/05dc3e946f635d00c5e0b21aae6203a7, a step-by-step guide. Find more about libPFM @ https://perfmon2.sourceforge.net.

> [!TIP]
> Git submodule based dependencies will normally be imported automatically, but in case that doesn't work, you can manually initialize and update them by issuing `$ git submodule update --init` from inside the root of this repository.

## Testing

For testing functional correctness of this implementation and conformance with ML-KEM draft standard, you have to issue

> [!NOTE]
> Known Answer Test (KAT) files living in [this](./kats/) directory are generated by following (reproducible) steps, described in https://gist.github.com/itzmeanjan/c8f5bc9640d0f0bdd2437dfe364d7710.

```bash
make -j            # Run tests without any sort of sanitizers
make asan_test -j  # Run tests with AddressSanitizer enabled
make ubsan_test -j # Run tests with UndefinedBehaviourSanitizer enabled
```

```bash
PASSED TESTS (9/9):
       3 ms: build/test.out ML_KEM.ML_KEM_512_KeygenEncapsDecaps
       3 ms: build/test.out ML_KEM.PolynomialSerialization
       4 ms: build/test.out ML_KEM.ML_KEM_768_KeygenEncapsDecaps
       4 ms: build/test.out ML_KEM.ML_KEM_1024_KeygenEncapsDecaps
      41 ms: build/test.out ML_KEM.ML_KEM_512_KnownAnswerTests
      63 ms: build/test.out ML_KEM.ML_KEM_1024_KnownAnswerTests
      64 ms: build/test.out ML_KEM.ML_KEM_768_KnownAnswerTests
     226 ms: build/test.out ML_KEM.CompressDecompressZq
     284 ms: build/test.out ML_KEM.ArithmeticOverZq
```

In case you're interested in running timing leakage tests using `dudect`, execute following

> [!NOTE]
> `dudect` is integrated into this library implementation of ML-KEM to find any sort of timing leakages. It checks for constant-timeness of all *vital* functions including Fujisaki-Okamoto transform, used in decapsulation step. It doesn't check constant-timeness of function which samples public matrix `A`, because that fails the check anyway, due to use of uniform rejection sampling. As matrix `A` is public, it's not critical that it must be *strictly* constant-time.

```bash
# Can only be built and run x86_64 machine.

make dudect_test_build -j

# Before running the constant-time tests, it's a good idea to put all CPU cores on "performance" mode.
# You may find guide @ https://github.com/google/benchmark/blob/main/docs/reducing_variance.md helpful.

timeout 10m taskset -c 0 ./build/dudect/test_ml_kem_512.out
timeout 10m taskset -c 0 ./build/dudect/test_ml_kem_768.out
timeout 10m taskset -c 0 ./build/dudect/test_ml_kem_1024.out
```

> [!TIP]
> `dudect` documentation says if `t` statistic is < 10, we're *probably* good, yes **probably**. You may want to read `dudect` documentation @ https://github.com/oreparaz/dudect. Also you might find the original paper @ https://ia.cr/2016/1123 interesting.

```bash
...
meas:   58.90 M, max t:   +2.61, max tau: 3.40e-04, (5/tau)^2: 2.16e+08. For the moment, maybe constant time.
meas:   58.99 M, max t:   +2.65, max tau: 3.45e-04, (5/tau)^2: 2.10e+08. For the moment, maybe constant time.
meas:   59.07 M, max t:   +2.65, max tau: 3.44e-04, (5/tau)^2: 2.11e+08. For the moment, maybe constant time.
meas:   59.16 M, max t:   +2.63, max tau: 3.42e-04, (5/tau)^2: 2.13e+08. For the moment, maybe constant time.
meas:   59.25 M, max t:   +2.68, max tau: 3.49e-04, (5/tau)^2: 2.06e+08. For the moment, maybe constant time.
meas:   59.33 M, max t:   +2.65, max tau: 3.44e-04, (5/tau)^2: 2.12e+08. For the moment, maybe constant time.
meas:   59.42 M, max t:   +2.75, max tau: 3.57e-04, (5/tau)^2: 1.96e+08. For the moment, maybe constant time.
meas:   59.50 M, max t:   +2.72, max tau: 3.53e-04, (5/tau)^2: 2.01e+08. For the moment, maybe constant time.
meas:   59.59 M, max t:   +2.68, max tau: 3.47e-04, (5/tau)^2: 2.08e+08. For the moment, maybe constant time.
meas:   59.66 M, max t:   +2.70, max tau: 3.50e-04, (5/tau)^2: 2.04e+08. For the moment, maybe constant time.
meas:   59.74 M, max t:   +2.70, max tau: 3.50e-04, (5/tau)^2: 2.05e+08. For the moment, maybe constant time.
meas:   59.82 M, max t:   +2.72, max tau: 3.51e-04, (5/tau)^2: 2.03e+08. For the moment, maybe constant time.
meas:   59.89 M, max t:   +2.72, max tau: 3.51e-04, (5/tau)^2: 2.03e+08. For the moment, maybe constant time.
meas:   59.97 M, max t:   +2.64, max tau: 3.41e-04, (5/tau)^2: 2.14e+08. For the moment, maybe constant time.
```

## Benchmarking

For benchmarking ML-KEM public functions such as keygen, encaps and decaps, for various suggested parameter sets, you have to issue.

```bash
make benchmark -j  # If you haven't built google-benchmark library with libPFM support.
make perf -j       # If you have built google-benchmark library with libPFM support.
```

> [!CAUTION]
> When benchmarking, ensure that you've disabled CPU frequency scaling, by following guide @ https://github.com/google/benchmark/blob/main/docs/reducing_variance.md.

> [!NOTE]
> `make perf` - was issued when collecting following benchmarks. Notice, *cycles* column, denoting cost of executing ML-KEM functions, in terms of CPU cycles. Follow https://github.com/google/benchmark/blob/main/docs/perf_counters.md for more details.

### On 12th Gen Intel(R) Core(TM) i7-1260P

Compiled with **gcc version 13.2.0 (Ubuntu 13.2.0-4ubuntu3)**.

```bash
$ uname -srm
Linux 6.5.0-14-generic x86_64
```

```bash
2024-01-22T19:09:06+04:00
Running ./build/perf.out
Run on (16 X 752.14 MHz CPU s)
CPU Caches:
  L1 Data 48 KiB (x8)
  L1 Instruction 32 KiB (x8)
  L2 Unified 1280 KiB (x8)
  L3 Unified 18432 KiB (x1)
Load Average: 1.35, 0.74, 0.64
---------------------------------------------------------------------------------------------------------
Benchmark                        Time             CPU   Iterations     CYCLES items_per_second      rdtsc
---------------------------------------------------------------------------------------------------------
kyber512/keygen_mean          14.1 us         14.1 us           10   64.8786k       71.1611k/s    35.056k
kyber512/keygen_median        13.9 us         13.9 us           10   64.8328k       71.8418k/s    34.704k
kyber512/keygen_stddev       0.363 us        0.362 us           10    533.391       1.73436k/s    903.837
kyber512/keygen_cv            2.58 %          2.57 %            10      0.82%            2.44%      2.58%
kyber512/keygen_min           13.8 us         13.8 us           10   64.1864k       66.4408k/s    34.367k
kyber512/keygen_max           15.1 us         15.1 us           10   66.2011k       72.5455k/s    37.531k
kyber1024/decap_mean          47.9 us         47.9 us           10   222.332k       20.8836k/s   119.488k
kyber1024/decap_median        47.8 us         47.8 us           10    222.36k        20.909k/s   119.335k
kyber1024/decap_stddev       0.345 us        0.345 us           10    847.653        149.328/s    860.065
kyber1024/decap_cv            0.72 %          0.72 %            10      0.38%            0.72%      0.72%
kyber1024/decap_min           47.4 us         47.4 us           10   220.724k        20.529k/s   118.295k
kyber1024/decap_max           48.7 us         48.7 us           10   223.956k       21.0947k/s   121.542k
kyber768/encap_mean           28.9 us         28.9 us           10   133.838k        34.632k/s   72.0448k
kyber768/encap_median         28.8 us         28.8 us           10   133.943k       34.7766k/s    71.729k
kyber768/encap_stddev        0.389 us        0.389 us           10    424.097        455.864/s    969.721
kyber768/encap_cv             1.35 %          1.35 %            10      0.32%            1.32%      1.35%
kyber768/encap_min            28.5 us         28.5 us           10   133.171k        33.474k/s    71.097k
kyber768/encap_max            29.9 us         29.9 us           10   134.415k       35.0874k/s    74.524k
kyber512/encap_mean           17.5 us         17.5 us           10   81.3077k       56.9959k/s   43.7583k
kyber512/encap_median         17.5 us         17.5 us           10   81.3109k       57.1806k/s    43.614k
kyber512/encap_stddev        0.178 us        0.178 us           10    224.364        572.266/s     443.14
kyber512/encap_cv             1.01 %          1.01 %            10      0.28%            1.00%      1.01%
kyber512/encap_min            17.3 us         17.3 us           10   80.9421k       55.7884k/s    43.182k
kyber512/encap_max            17.9 us         17.9 us           10   81.6759k       57.7496k/s    44.702k
kyber1024/encap_mean          44.1 us         44.1 us           10   204.634k       22.6603k/s   110.119k
kyber1024/encap_median        44.0 us         44.0 us           10    204.79k       22.7169k/s   109.836k
kyber1024/encap_stddev       0.358 us        0.356 us           10    751.071        180.658/s    891.891
kyber1024/encap_cv            0.81 %          0.81 %            10      0.37%            0.80%      0.81%
kyber1024/encap_min           43.7 us         43.7 us           10   202.876k       22.2099k/s   109.114k
kyber1024/encap_max           45.0 us         45.0 us           10   205.644k       22.8667k/s   112.348k
kyber1024/keygen_mean         37.6 us         37.6 us           10   174.399k       26.5696k/s   93.9229k
kyber1024/keygen_median       37.7 us         37.7 us           10   174.662k       26.5444k/s    94.024k
kyber1024/keygen_stddev      0.417 us        0.415 us           10   1.34601k        292.441/s   1.04079k
kyber1024/keygen_cv           1.11 %          1.10 %            10      0.77%            1.10%      1.11%
kyber1024/keygen_min          36.9 us         36.9 us           10   172.239k       26.0098k/s    91.983k
kyber1024/keygen_max          38.5 us         38.4 us           10   176.088k       27.1239k/s    95.953k
kyber768/keygen_mean          23.6 us         23.6 us           10    109.11k       42.3017k/s   58.9747k
kyber768/keygen_median        23.7 us         23.7 us           10   109.577k       42.2725k/s   59.0055k
kyber768/keygen_stddev       0.310 us        0.310 us           10    786.552        554.447/s    772.922
kyber768/keygen_cv            1.31 %          1.31 %            10      0.72%            1.31%      1.31%
kyber768/keygen_min           23.2 us         23.2 us           10   108.011k       41.3191k/s    57.748k
kyber768/keygen_max           24.2 us         24.2 us           10   109.909k       43.1928k/s     60.37k
kyber512/decap_mean           19.7 us         19.7 us           10   91.4808k       50.6517k/s   49.2443k
kyber512/decap_median         19.7 us         19.7 us           10   91.4678k       50.6475k/s   49.2465k
kyber512/decap_stddev        0.186 us        0.186 us           10    554.643        475.223/s    463.271
kyber512/decap_cv             0.94 %          0.94 %            10      0.61%            0.94%      0.94%
kyber512/decap_min            19.5 us         19.5 us           10   90.7913k       49.8154k/s    48.691k
kyber512/decap_max            20.1 us         20.1 us           10   92.7485k       51.2228k/s    50.066k
kyber768/decap_mean           31.8 us         31.8 us           10   147.512k       31.4865k/s   79.2379k
kyber768/decap_median         31.7 us         31.7 us           10    147.59k       31.5118k/s   79.1735k
kyber768/decap_stddev        0.129 us        0.128 us           10    344.756         126.89/s    320.866
kyber768/decap_cv             0.41 %          0.40 %            10      0.23%            0.40%      0.40%
kyber768/decap_min            31.6 us         31.6 us           10   146.652k       31.2195k/s    78.891k
kyber768/decap_max            32.0 us         32.0 us           10   147.851k       31.6233k/s    79.914k
```

### On ARM Cortex-A72 i.e. Raspberry Pi 4B

Compiled with **gcc version 13.2.0 (Ubuntu 13.2.0-4ubuntu3)**.

```bash
$ uname -srm
Linux 6.5.0-1008-raspi aarch64
```

```bash
2024-01-22T19:22:33+04:00
Running ./build/perf.out
Run on (4 X 1800 MHz CPU s)
CPU Caches:
  L1 Data 32 KiB (x4)
  L1 Instruction 48 KiB (x4)
  L2 Unified 1024 KiB (x1)
Load Average: 2.32, 2.85, 1.46
----------------------------------------------------------------------------------------------
Benchmark                        Time             CPU   Iterations     CYCLES items_per_second
----------------------------------------------------------------------------------------------
kyber1024/decap_mean           250 us          250 us           10    448.76k       4.00416k/s
kyber1024/decap_median         250 us          250 us           10   448.888k       4.00246k/s
kyber1024/decap_stddev       0.401 us        0.405 us           10    738.224        6.49398/s
kyber1024/decap_cv            0.16 %          0.16 %            10      0.16%            0.16%
kyber1024/decap_min            249 us          249 us           10    447.75k       3.99346k/s
kyber1024/decap_max            251 us          250 us           10    450.06k       4.01306k/s
kyber512/decap_mean            106 us          106 us           10   189.763k         9.469k/s
kyber512/decap_median          106 us          106 us           10   189.753k        9.4696k/s
kyber512/decap_stddev        0.293 us        0.291 us           10    529.974        26.0654/s
kyber512/decap_cv             0.28 %          0.28 %            10      0.28%            0.28%
kyber512/decap_min             105 us          105 us           10   189.096k       9.41547k/s
kyber512/decap_max             106 us          106 us           10   190.852k       9.50263k/s
kyber768/encap_mean            148 us          148 us           10   265.507k       6.76869k/s
kyber768/encap_median          148 us          148 us           10    265.41k       6.77083k/s
kyber768/encap_stddev        0.566 us        0.567 us           10    1.0282k        25.9589/s
kyber768/encap_cv             0.38 %          0.38 %            10      0.39%            0.38%
kyber768/encap_min             147 us          147 us           10   263.583k       6.71972k/s
kyber768/encap_max             149 us          149 us           10   267.479k       6.81811k/s
kyber512/encap_mean           90.0 us         90.0 us           10   161.649k        11.117k/s
kyber512/encap_median         90.0 us         89.9 us           10   161.581k        11.121k/s
kyber512/encap_stddev        0.345 us        0.347 us           10    626.388        42.6811/s
kyber512/encap_cv             0.38 %          0.39 %            10      0.39%            0.38%
kyber512/encap_min            89.6 us         89.6 us           10   160.933k       11.0122k/s
kyber512/encap_max            90.9 us         90.8 us           10   163.199k       11.1667k/s
kyber768/keygen_mean           119 us          119 us           10   213.516k         8.416k/s
kyber768/keygen_median         119 us          119 us           10   213.534k       8.41435k/s
kyber768/keygen_stddev       0.275 us        0.277 us           10    496.099        19.6189/s
kyber768/keygen_cv            0.23 %          0.23 %            10      0.23%            0.23%
kyber768/keygen_min            118 us          118 us           10   212.691k        8.3908k/s
kyber768/keygen_max            119 us          119 us           10   214.168k       8.44783k/s
kyber1024/keygen_mean          188 us          188 us           10   337.777k        5.3203k/s
kyber1024/keygen_median        188 us          188 us           10   337.479k       5.32517k/s
kyber1024/keygen_stddev      0.785 us        0.791 us           10   1.42498k        22.2604/s
kyber1024/keygen_cv           0.42 %          0.42 %            10      0.42%            0.42%
kyber1024/keygen_min           187 us          187 us           10   336.121k       5.26713k/s
kyber1024/keygen_max           190 us          190 us           10   341.212k       5.34588k/s
kyber512/keygen_mean          69.0 us         68.9 us           10   123.818k       14.5129k/s
kyber512/keygen_median        69.0 us         68.9 us           10   123.807k       14.5138k/s
kyber512/keygen_stddev       0.152 us        0.148 us           10    253.268        31.0736/s
kyber512/keygen_cv            0.22 %          0.21 %            10      0.20%            0.21%
kyber512/keygen_min           68.7 us         68.7 us           10   123.395k       14.4549k/s
kyber512/keygen_max           69.2 us         69.2 us           10   124.311k       14.5653k/s
kyber768/decap_mean            170 us          170 us           10   304.634k       5.89868k/s
kyber768/decap_median          170 us          169 us           10   304.463k        5.9015k/s
kyber768/decap_stddev        0.654 us        0.648 us           10   1.15668k        22.5143/s
kyber768/decap_cv             0.39 %          0.38 %            10      0.38%            0.38%
kyber768/decap_min             169 us          169 us           10   303.091k       5.86043k/s
kyber768/decap_max             171 us          171 us           10   306.634k       5.92931k/s
kyber1024/encap_mean           224 us          224 us           10   401.823k       4.47202k/s
kyber1024/encap_median         224 us          223 us           10   401.482k        4.4752k/s
kyber1024/encap_stddev       0.802 us        0.804 us           10   1.47807k         16.038/s
kyber1024/encap_cv            0.36 %          0.36 %            10      0.37%            0.36%
kyber1024/encap_min            223 us          223 us           10   400.254k       4.44088k/s
kyber1024/encap_max            225 us          225 us           10   404.723k       4.48965k/s
```

### On Apple M1 Max

Compiled with **Apple clang version 15.0.0 (clang-1500.1.0.2.5)**.

```bash
$ uname -srm
Darwin 23.2.0 arm64
```

```bash
2024-01-22T19:33:49+04:00
Running ./build/bench.out
Run on (10 X 24 MHz CPU s)
CPU Caches:
  L1 Data 64 KiB
  L1 Instruction 128 KiB
  L2 Unified 4096 KiB (x10)
Load Average: 2.44, 2.58, 2.80
-----------------------------------------------------------------------------------
Benchmark                        Time             CPU   Iterations items_per_second
-----------------------------------------------------------------------------------
kyber768/keygen_mean          20.2 us         20.2 us           10       49.5202k/s
kyber768/keygen_median        20.2 us         20.2 us           10       49.5691k/s
kyber768/keygen_stddev       0.078 us        0.075 us           10        182.819/s
kyber768/keygen_cv            0.39 %          0.37 %            10            0.37%
kyber768/keygen_min           20.2 us         20.1 us           10       49.0094k/s
kyber768/keygen_max           20.5 us         20.4 us           10       49.6414k/s
kyber1024/encap_mean          38.4 us         38.3 us           10       26.1344k/s
kyber1024/encap_median        38.3 us         38.2 us           10       26.1544k/s
kyber1024/encap_stddev       0.130 us        0.127 us           10        86.5122/s
kyber1024/encap_cv            0.34 %          0.33 %            10            0.33%
kyber1024/encap_min           38.2 us         38.1 us           10        25.957k/s
kyber1024/encap_max           38.6 us         38.5 us           10       26.2225k/s
kyber512/keygen_mean          12.0 us         11.9 us           10       83.7302k/s
kyber512/keygen_median        12.0 us         11.9 us           10       83.7409k/s
kyber512/keygen_stddev       0.019 us        0.020 us           10        141.747/s
kyber512/keygen_cv            0.16 %          0.17 %            10            0.17%
kyber512/keygen_min           11.9 us         11.9 us           10       83.5254k/s
kyber512/keygen_max           12.0 us         12.0 us           10       83.9197k/s
kyber768/encap_mean           25.0 us         24.9 us           10       40.0959k/s
kyber768/encap_median         25.0 us         24.9 us           10        40.106k/s
kyber768/encap_stddev        0.053 us        0.056 us           10        89.5965/s
kyber768/encap_cv             0.21 %          0.22 %            10            0.22%
kyber768/encap_min            24.9 us         24.8 us           10       39.9002k/s
kyber768/encap_max            25.1 us         25.1 us           10       40.2567k/s
kyber1024/keygen_mean         32.3 us         32.2 us           10       31.0263k/s
kyber1024/keygen_median       32.3 us         32.2 us           10       31.0496k/s
kyber1024/keygen_stddev      0.100 us        0.098 us           10        94.0295/s
kyber1024/keygen_cv           0.31 %          0.31 %            10            0.30%
kyber1024/keygen_min          32.2 us         32.2 us           10       30.7662k/s
kyber1024/keygen_max          32.6 us         32.5 us           10       31.0832k/s
kyber768/decap_mean           26.2 us         26.1 us           10       38.2517k/s
kyber768/decap_median         26.2 us         26.1 us           10       38.2788k/s
kyber768/decap_stddev        0.072 us        0.071 us           10        103.849/s
kyber768/decap_cv             0.27 %          0.27 %            10            0.27%
kyber768/decap_min            26.1 us         26.1 us           10       37.9778k/s
kyber768/decap_max            26.4 us         26.3 us           10       38.3546k/s
kyber512/encap_mean           15.2 us         15.1 us           10       66.0548k/s
kyber512/encap_median         15.2 us         15.1 us           10       66.0441k/s
kyber512/encap_stddev        0.019 us        0.018 us           10        76.3748/s
kyber512/encap_cv             0.13 %          0.12 %            10            0.12%
kyber512/encap_min            15.1 us         15.1 us           10       65.9247k/s
kyber512/encap_max            15.2 us         15.2 us           10       66.1939k/s
kyber1024/decap_mean          39.7 us         39.6 us           10       25.2636k/s
kyber1024/decap_median        39.7 us         39.6 us           10       25.2559k/s
kyber1024/decap_stddev       0.052 us        0.047 us           10        30.0564/s
kyber1024/decap_cv            0.13 %          0.12 %            10            0.12%
kyber1024/decap_min           39.6 us         39.5 us           10       25.2259k/s
kyber1024/decap_max           39.8 us         39.6 us           10       25.3094k/s
kyber512/decap_mean           16.1 us         16.1 us           10       62.1168k/s
kyber512/decap_median         16.1 us         16.1 us           10       62.1323k/s
kyber512/decap_stddev        0.023 us        0.024 us           10        93.9076/s
kyber512/decap_cv             0.14 %          0.15 %            10            0.15%
kyber512/decap_min            16.1 us         16.1 us           10       61.9199k/s
kyber512/decap_max            16.2 us         16.1 us           10       62.2184k/s
```

## Usage

`kyber` is written as a header-only C++20 `constexpr` library, majorly targeting 64 -bit desktop/ server grade platforms and it's pretty easy to get started with. All you need to do is following.

- Clone `kyber` repository.

```bash
cd

# Multi-step cloning and importing of submodules
git clone https://github.com/itzmeanjan/kyber.git && pushd kyber && git submodule update --init && popd
# Or do single step cloning and importing of submodules
git clone https://github.com/itzmeanjan/kyber.git --recurse-submodules
```

- Write your program while including proper header files ( based on which variant of ML-KEM you want to use, see [include](./include) directory ), which includes declarations ( and definitions ) of all required ML-KEM routines and constants ( such as byte length of public/ private key, cipher text etc. ).

```cpp
// main.cpp

#include "ml_kem/ml_kem_512.hpp"
#include <algorithm>
#include <array>
#include <cassert>

int
main()
{
  std::array<uint8_t, ml_kem_512::SEED_D_BYTE_LEN> d{};
  std::array<uint8_t, ml_kem_512::SEED_Z_BYTE_LEN> z{};

  std::array<uint8_t, ml_kem_512::PKEY_BYTE_LEN> pkey{};
  std::array<uint8_t, ml_kem_512::SKEY_BYTE_LEN> skey{};

  std::array<uint8_t, ml_kem_512::SEED_M_BYTE_LEN> m{};
  std::array<uint8_t, ml_kem_512::CIPHER_TEXT_BYTE_LEN> cipher{};

  std::array<uint8_t, ml_kem_512::SHARED_SECRET_BYTE_LEN> sender_key{};
  std::array<uint8_t, ml_kem_512::SHARED_SECRET_BYTE_LEN> receiver_key{};

  // Be careful !
  //
  // Read API documentation in include/ml_kem/internals/rng/prng.hpp
  ml_kem_prng::prng_t<128> prng;

  prng.read(d);
  prng.read(z);
  prng.read(m);

  ml_kem_512::keygen(d, z, pkey, skey);
  assert(ml_kem_512::encapsulate(m, pkey, cipher, sender_key)); // Key Encapsulation might fail, if input public key is malformed
  ml_kem_512::decapsulate(skey, cipher, receiver_key);

  assert(sender_key == receiver_key);
  return 0;
}
```

- When compiling your program, let your compiler know where it can find `kyber`, `sha3` and `subtle` headers, which includes their definitions ( all of them are header-only libraries ) too.

```bash
# Assuming `kyber` was cloned just under $HOME

KYBER_HEADERS=~/kyber/include
SHA3_HEADERS=~/kyber/sha3/include
SUBTLE_HEADERS=~/kyber/subtle/include

g++ -std=c++20 -Wall -Wextra -pedantic -O3 -march=native -I $KYBER_HEADERS -I $SHA3_HEADERS -I $SUBTLE_HEADERS main.cpp
```

ML-KEM Variant | Namespace | Header
:-- | :-: | --:
ML-KEM-512 Routines | `ml_kem_512::` | `include/ml_kem/ml_kem_512.hpp`
ML-KEM-768 Routines | `ml_kem_768::` | `include/ml_kem/ml_kem_768.hpp`
ML-KEM-1024 Routines | `ml_kem_1024::` | `include/ml_kem/ml_kem_1024.hpp`

> [!NOTE]
> ML-KEM parameter sets are taken from table 2 of ML-KEM draft standard @ https://doi.org/10.6028/NIST.FIPS.203.ipd.

See example [program](./examples/ml_kem_768.cpp), where I show how to use ML-KEM-512 API.

```bash
g++ -std=c++20 -Wall -Wextra -pedantic -O3 -march=native -I ./include -I ./sha3/include -I ./subtle/include/ examples/ml_kem_768.cpp && ./a.out
```

```bash
ML-KEM-768
Pubkey         : 6653a1f5242faad7b37863433dc56538957f3c412102a17d28bc328c4781c566331f8c0b77093baef24a58d6312ddc719ac67ac2874f3adc8a3e6530adbc14cc069159a99e56277895c17c04da1644db23a6e9c16f31c21959400a8abd483a3fcfc0c5fd759917322a66a2aa77a6956f3b8387443640746b0ac8a282521dd784332d56aa745898c3fcc60a56a0716931bbe69b26c4514d529c79979355c8b40eb97fe7c485ceaa45d610145b4bce7da6343db46b6bf42182931a3ed98bafb66614e024cf8c9e51a90b1fc3702a2b4fe3b0c537fa9a1680b4d2f2044c557b1819300a6225be6c234d07d06a702eeb7110ef05c8973b0cab182efbb9ba07811b87b24e2a652cb428240c53423efcaf201973bf3342e86a8d477191d3544217f143586ba351fb7729ac8a51a51c8ab719fd3568c615a7a438b8967301754cac96a8552af82d8ce8840da56cb7481ad54581904c0d390732eceb23df4483cd7593d949bb0c985042f71018862b0d126702a7b55c8c7d9d44cfea157d4013c57ceb18bcfc2c95d8bb8d6178e0ac738ffcc1b3fca525a7ae83652e0b75836fe6c77d182626a8ca85262a17bc60645105a503b2f0f707e765552d49979273b0cb5870124933c6557ef795b36bf093f6c35ef722c9b2854999d20b5fd23dc6d2381ef38bcf547e37faa8ccda3dea2409deda7992a1951849ce3e7b11f3f98cb0d2283e458af854af9d74c57516a924e74222e9bcac529e88a02913d9ae29ec3cc42269d08ca1bf13a941f95d0bb05da9ac4a1ea2bb86b4c631853ec5f2129834a70ba923c8f1bc3fd5cad8692ef4401417b362f0e729497633794abc21e95a59319403002085b113a7b0544165210c1726346a088a933347a265ba055429e637fc40b111d38446461d77546166f923e5249427e5c62092b6ee2a2b585273c3d545b99673419194e54978d71ca606e238a053988db999904207b8326c5b27a38966c4d99460386c453d12821602b444320da205c980da3ab9d3461d405601a7226c143cf4492b8bf4c63a949a8ad81224c71005abcf6afb4ba7ba94ee437079494f9d78c69ac950711765a7e50ab42ba6bf64a5a7d30e64d14fb845ab37b4cc5b099c44e3cf4f9bc61f3640b5b98560474f9f1054dce9be10db77dea35a2375c66d0a26d7f73e7385b03ca8194dbaaf601184f826bd0a86b1d023ae9548b6d4602cd25c3f46e1c66dca6fd183007d043f6f3a6f5a56089180744d579bfe3cc65f003d91084adac4c0ac5811ea8a3e5aa6500eac125a423000297a7975585a083bcfc807b7722b5a0438c1b11b62abcb9a4623f8090c451690455acf97814074c0b6d6d19180f08afbd5ba0e259ee910a61f684d14e7996e47ba5a19994a13a642a1bb563411979bcaf7b302d70ba750a89867653b93596d03b260c7c0a024949bb7b1b110dc8267d5c5305390da26c7e6296add6ba7533b92540c28b337c5b392a6024c57cc09b899ec72e1466de604aa0c909baeb0b0078324e810481f760ae694b5e88cb034bca48bf70881047c7b6ab7ce04b96ad2bd0142b387bc1824a22742c7ce18ebac7744a616a5631e40ab817426c6130ece8641661ab863c44c2adb64029990aea24c94bec0ad7bfba46cd1894775ac6549b1a63446cade59357e125c589a73
Seckey         : 7fc5b38c54324b214d9db93e4069c03a097931156a9e18291ac9b0ac787dfcd189a5971b3dd79fab1b5bacbb35a8d33d08faa3493c8d26886c0f487bee757b16837799912bbd99200502227ff510a4c39d924434af8233220084888b134fb608b9d424c66b8ec5c34069327c5ac591ee0b774ef42f922aceeae21d44738b74e644c5dc0fff4c8ed2cb25f495126840442370159a7c5bb6631c4b7aa4d0445a1fa63c104b492e986e1109bcab369fa0889ca41202d22c8511b8a35719163336a87ea672798168038439ab5645acf813f773a0a575169250c2a2062618aa3b77d015750abaf6a707019945e590beaf6cc499b8305ef66583e42c24f9b2d720ac286a8b513261d36a4c34eb7a6a012488aa3e58553e5245ac7e7089d327568ec66e9bccc96fa5ce0bcc8b1fda3343857adc564d4a631e695b7ecea241947561519b48a75b4f89ab992f201d3f5c958254c9c8653ee2d08756388152db8284d0a48db1a7b96282e4b168cf16a51362534c4c90ca21c28f5b76a12c6042f61a7de52c2bf8901f3738cec81c1ac75399b63320217ce8833e06c0b022b5883415009e08428cc07570660cd14a818cc2ad1a00aeb011b9622a48dde6632277b784d28651c17438d8457e67a6dbc016e387cdabf15e3c456c17c1b3825376bdb3c3f418ac251c96605b208f35c0027559405240bc419303ea9d1c9a36c10ccc0b443782e1c1e860ad0af914ab7a53cfaa0d7ef1100be74da5b43fcfe4bc60e7397cf009ddda713eb7610a15716e9b9e7ac55269c9494bc910a3753c0a0942ec654f1500826f900bb4776dde03166ef376dd67cc385406d2f4047ffc819b2657e596c964189727f3b8a9705f4dc011fda20c73846f62146085547d872519636697e16c7e89d741c917974e490812482ab704099e003acab375f1376536b85c5c12196b2a7514461a2fc2032bb65164f6cbe16c8fb6754a3cd75bb26635a1f5b96d113dfb1a3b301438608c39be68adb5b359d00b0b39a77f7167a18c75532b18798aea17d6ea64bf798c3ec0438a1c94d3445f906985f3791a3f4a98df13cd0af24d8feba0dbeb08b42635327c31cff5b6da791ad1c33055b18fa6d8b5c7f454c39a70d1e86f96660cea737e7ca52014a6c662e346a09bc25e4027602b4472dc93ee06c91a698be675bb39d2319e91a083b92e4b7b0bcc38771977c300e889ae60bb38b97ca68836d0bcabde4b6a0d70042ee67e051a1503927c422593df1668bb789d7060cc6b09d0a891384d5bbe90b480ba93afa99a079ea85e28a0236437a0ba397705356b0f90757e754f34fb5a591b3888eb5d719b79f462abab333ed078bb90c4b11dec276713c4cb06bca9d98068f48b90802451f69d2acb08abe66c61f6081f008d04fa7bad176da4201c9c2a3b3b29b3e7734b1961b6e2ea8d963350d8301a2dc48ce2e056156275cae8c23665b47a5a49c1abc5a01c98cee22a9dd7584c15b304e5c61cd449453208417075a6c3b999f626795379f1d556da168832a47ac638ce89a59c5a9c0a9746ad219142cf782280311b9cea87598c46ba673ac30a281a052dcd710e1bac328d822c19db8ee7e38925c7378431937b812e03382963b9c26653a1f5242faad7b37863433dc56538957f3c412102a17d28bc328c4781c566331f8c0b77093baef24a58d6312ddc719ac67ac2874f3adc8a3e6530adbc14cc069159a99e56277895c17c04da1644db23a6e9c16f31c21959400a8abd483a3fcfc0c5fd759917322a66a2aa77a6956f3b8387443640746b0ac8a282521dd784332d56aa745898c3fcc60a56a0716931bbe69b26c4514d529c79979355c8b40eb97fe7c485ceaa45d610145b4bce7da6343db46b6bf42182931a3ed98bafb66614e024cf8c9e51a90b1fc3702a2b4fe3b0c537fa9a1680b4d2f2044c557b1819300a6225be6c234d07d06a702eeb7110ef05c8973b0cab182efbb9ba07811b87b24e2a652cb428240c53423efcaf201973bf3342e86a8d477191d3544217f143586ba351fb7729ac8a51a51c8ab719fd3568c615a7a438b8967301754cac96a8552af82d8ce8840da56cb7481ad54581904c0d390732eceb23df4483cd7593d949bb0c985042f71018862b0d126702a7b55c8c7d9d44cfea157d4013c57ceb18bcfc2c95d8bb8d6178e0ac738ffcc1b3fca525a7ae83652e0b75836fe6c77d182626a8ca85262a17bc60645105a503b2f0f707e765552d49979273b0cb5870124933c6557ef795b36bf093f6c35ef722c9b2854999d20b5fd23dc6d2381ef38bcf547e37faa8ccda3dea2409deda7992a1951849ce3e7b11f3f98cb0d2283e458af854af9d74c57516a924e74222e9bcac529e88a02913d9ae29ec3cc42269d08ca1bf13a941f95d0bb05da9ac4a1ea2bb86b4c631853ec5f2129834a70ba923c8f1bc3fd5cad8692ef4401417b362f0e729497633794abc21e95a59319403002085b113a7b0544165210c1726346a088a933347a265ba055429e637fc40b111d38446461d77546166f923e5249427e5c62092b6ee2a2b585273c3d545b99673419194e54978d71ca606e238a053988db999904207b8326c5b27a38966c4d99460386c453d12821602b444320da205c980da3ab9d3461d405601a7226c143cf4492b8bf4c63a949a8ad81224c71005abcf6afb4ba7ba94ee437079494f9d78c69ac950711765a7e50ab42ba6bf64a5a7d30e64d14fb845ab37b4cc5b099c44e3cf4f9bc61f3640b5b98560474f9f1054dce9be10db77dea35a2375c66d0a26d7f73e7385b03ca8194dbaaf601184f826bd0a86b1d023ae9548b6d4602cd25c3f46e1c66dca6fd183007d043f6f3a6f5a56089180744d579bfe3cc65f003d91084adac4c0ac5811ea8a3e5aa6500eac125a423000297a7975585a083bcfc807b7722b5a0438c1b11b62abcb9a4623f8090c451690455acf97814074c0b6d6d19180f08afbd5ba0e259ee910a61f684d14e7996e47ba5a19994a13a642a1bb563411979bcaf7b302d70ba750a89867653b93596d03b260c7c0a024949bb7b1b110dc8267d5c5305390da26c7e6296add6ba7533b92540c28b337c5b392a6024c57cc09b899ec72e1466de604aa0c909baeb0b0078324e810481f760ae694b5e88cb034bca48bf70881047c7b6ab7ce04b96ad2bd0142b387bc1824a22742c7ce18ebac7744a616a5631e40ab817426c6130ece8641661ab863c44c2adb64029990aea24c94bec0ad7bfba46cd1894775ac6549b1a63446cade59357e125c589a73dd18d5e8aad6acb35a89e0958c3ae122197bb6fed165733ca120172d11335a4d60d73fb91d0ffac552692219ef3082477a0f6399aa5dce8a72fd0afaa3b627c9
Encapsulated ? : true
Cipher         : 1d04afad6cf4058acb290f72298587c8afb9e022fc0a4b3e1aa5fdc79cfbe44e7781317adbc1f92fd01a6ad3840386710a369276c50671d2b58272505793736bb9d0e8883c200270ddae19fbc86af41aba366b4ddfd67f8771905b3fccca6da805a1e13a9e697500779cfe52484811e906042fa6e6e93ef641e5e7a46c39969c4683ee7cb440fc4cc452dab5215d6ec32a36fa0e8d7501b5d7dcc9dbfb51cbb1c036b052a7354544a6707099ded7b5e5c5024e2a6f356b2d300585128a30d7b964842d5c06659990c85468b42f5f2b46c39b4fa740a3f7006da01ffa09fb2fd6b5b0e9174bd7a801972b647df2825842b8ad146220a1ddcc9eee6967954e8d960bbf5ea8a74ae0306061c44e2995eb451171bd3eb4679579922e48e713ad40cddcd14343dc57a181e3067f1b01895122a447cf002b600c96a30c5f809efcc459cebc8723ca5b5147d2f9d09186f31bba013f19e63294cc5a57c0184b838cb9d51c62e0303c9a029cf6a5c489ccb43bd0bdd4da61f147d6ef9c2b95a758d0c2b9a9265e7cf4255989c07799940c517ecd527cca2acf62d104e2d45a176e35852d81f42397c93d3b2b1c7fde3cc6f4cd5d6c166f7312e34f690a07ecbaac69a045358564142422b45c58784cd5d2d69d9084b7e9f33176893bee2f1589725ed1a443f4b9095e97294f740e8471f468a51db85cc66176af022db77314579776b69eaa8594dbed5d0e0b549675e12c742913da76e3de732c24f7811d8ee32ade2ac1bcb8763c0e898a67695aaab9478c80dc29cc3ae9f1c4b63c116bda64e1e8727881ebe4c1db30219a87d7ff8805675b56a4907d9408bb96438a5182c66a47739f8b12cd5241b5f4e995f4f1fc85041eeaeb158d7ea9c1601a9b3849c6977137a0e82afb72b16748efa456fbae5b28ed82107d79dec3da87d0c0261267a3dbe9dcedb374d96fc00b7478b30f917b2312e7e79133923c2d9aba394bfcdbd00539f7d2d4fdecf9821fdb4c15f253e5ad80d10e360fb84b45e01415a4d5759cd5000ea5c4e80f60a887f9e8ad35ef7cabab83eeb59bf81b3bb10b440707e877c558ca9c80df8d3d8741b838ddf9a5e0e7826a1f6ee0c4f2241687ab0573b18814d21a668861962400148b45a24fdfeb3638a1f16b7c344b088cfffc851317753c1e0602bb0cbfb5357132baf29d6123862eb8b29229a5fd9b173ad4c1b098d11ff23f6ee1c7d357235e647dd99451162cfbed33b7d05df5578859538a9edbeae2cf8ac0903c36e7db352c147c11725a3c5c611b149a4c87e24589d9e31d30a9a8b2cdd863b8dd3ab8c90cde061426a2afedb4aff424cde10e70f1e38207d0fc8be467b4f063739d920bb1906144a704c7ba5be6645899270e5da6380dabfb16e7f906a1f484501005cb383692e054533697a63c8a2f8e1b891b37d5b23afef1de8f9a257f7c9577466fbd87223c5773795ac23ab4cfc0043a965e8695e764174bdc1c778d3d1d6e2a65d9cb7a4b1eb31ca818b0c8abe779fd61a34ee78cfc49fd7682
Shared secret  : ee30e0696c36480afb066fa2971535f195a30ce08aacc3dfc182ed0947a44f3a
```

> [!CAUTION]
> Before you consider using Psuedo Random Number Generator which comes with this library implementation, I strongly advice you to go through [include/ml_kem/internals/rng/prng.hpp](./include/ml_kem/internals/rng/prng.hpp).

> [!NOTE]
> Looking at API documentation, in header files, can give you good idea of how to use ML-KEM API. Note, this library doesn't expose any raw pointer based interface, rather everything is wrapped under statically defined `std::span` - which one can easily create from `std::{array, vector}`. I opt for using statically defined `std::span` based function interfaces because we always know, at compile-time, how many bytes the seeds/ keys/ cipher-texts/ shared-secrets are, for various different ML-KEM parameters. This gives much better type safety and compile-time error reporting.
